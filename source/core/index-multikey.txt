.. index:: index; multikey
.. _index-type-multi-key:
.. _index-type-multikey:

================
Multikey Indexes
================

.. default-domain:: mongodb

To index a field that holds an array value, MongoDB creates an index
key for each element in the array. These *multikey* indexes support
efficient queries against array fields. Multikey indexes can be
constructed over arrays that hold both scalar values (e.g. strings,
numbers) *and* nested documents.

.. include:: /images/index-multikey.rst

Create Multikey Index
---------------------

To create a multikey index, use the
:method:`db.collection.createIndex()` method:

.. code-block:: javascript

   db.coll.createIndex( { <field>: < 1 or -1 > } )

MongoDB automatically creates a multikey index if any indexed field is
an array; you do not need to explicitly specify the multikey type.

Index Bounds
------------

If an index is multikey, then computation of the index bounds follows
special rules. For details on multikey index bounds, see
:doc:`/core/multikey-index-bounds`.

Limitations
-----------

Compound Multikey Indexes
~~~~~~~~~~~~~~~~~~~~~~~~~

For a :ref:`compound <index-type-compound>` multikey index, each
indexed document can have *at most* one indexed field whose value is an
array. As such, you cannot create a compound multikey index if more than one
to-be-indexed field of a document is an array. Or, if a compound
multikey index already exists, you cannot insert a document that would
violate this restriction.

For example, consider a collection that contains the following document:

.. code-block:: javascript

   { _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: "AB - both arrays" }

You cannot create a compound multikey index ``{ a: 1, b: 1 }`` on the
collection since both the ``a`` and ``b`` fields are arrays.

But consider a collection that contains the following documents:

.. code-block:: javascript

   { _id: 1, a: [1, 2], b: 1, category: "A array" }
   { _id: 2, a: 1, b: [1, 2], category: "B array" }

A compound multikey index ``{ a: 1, b: 1 }`` is permissible since for
each document, only one field indexed by the compound multikey index is
an array; i.e. no document contains array values for both ``a`` and
``b`` fields. After creating the compound multikey index, if you
attempt to insert a document where both ``a`` and ``b`` fields are
arrays, MongoDB will fail the insert.

Shard Keys
~~~~~~~~~~

You **cannot** specify a multikey index as the shard key index.

.. versionchanged:: 2.6

   However, if the shard key index is a :ref:`prefix
   <compound-index-prefix>` of a compound index, the compound index is
   allowed to become a compound *multikey* index if one of the other
   keys (i.e. keys that are not part of the shard key) indexes an
   array. Compound multikey indexes can have an impact on performance.

Hashed Indexes
~~~~~~~~~~~~~~

:doc:`Hashed </core/index-hashed>` indexes **cannot** be multikey.

Covered Queries
~~~~~~~~~~~~~~~

.. include:: /includes/fact-multikey-index-covered-query.rst

Examples
--------

Index Basic Arrays
~~~~~~~~~~~~~~~~~~

Consider a ``survey`` collection with the following document:

.. code-block:: javascript

   { _id: 1, item: "ABC", ratings: [ 2, 5, 9 ] }

Create an index on the field ``ratings``:

.. code-block:: javascript

   db.survey.createIndex( { ratings: 1 } )

Since the ``ratings`` field contains an array, the index on ``ratings``
is multikey. The multikey index contains the following three index
keys, each pointing to the same document:

- ``2``,

- ``5``, and

- ``9``.

Index Arrays with Embedded Documents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can create multikey indexes on array fields that contain nested
objects.

Consider an ``inventory`` collection with documents of the following
form:

.. code-block:: javascript

   {
     _id: 1,
     item: "abc",
     stock: [
       { size: "S", color: "red", quantity: 25 },
       { size: "S", color: "blue", quantity: 10 },
       { size: "M", color: "blue", quantity: 50 }
     ]
   }
   {
     _id: 2,
     item: "def",
     stock: [
       { size: "S", color: "blue", quantity: 20 },
       { size: "M", color: "blue", quantity: 5 },
       { size: "M", color: "black", quantity: 10 },
       { size: "L", color: "red", quantity: 2 }
     ]
   }
   {
     _id: 3,
     item: "ijk",
     stock: [
       { size: "M", color: "blue", quantity: 15 },
       { size: "L", color: "blue", quantity: 100 },
       { size: "L", color: "red", quantity: 25 }
     ]
   }

   ...

The following operation creates a multikey index on the ``stock.size``
and ``stock.quantity`` fields:

.. code-block:: javascript

   db.inventory.createIndex( { "stock.size": 1, "stock.quantity": 1 } )

The compound multikey index can support queries with predicates that
include both indexed fields as well as predicates that include only the
index prefix ``"stock.size"``, as in the following examples:

.. code-block:: javascript

   db.inventory.find( { "stock.size": "M" } )
   db.inventory.find( { "stock.size": "S", "stock.quantity": { $gt: 20 } } )

For details on how MongoDB can combine multikey index bounds, see
:doc:`/core/multikey-index-bounds`. For more information on behavior of
compound indexes and prefixes, see :ref:`compound indexes and prefixes
<compound-index-prefix>`.

The compound multikey index can also support sort operations, such as
the following examples:

.. code-block:: javascript

   db.inventory.find( ).sort( { "stock.size": 1, "stock.quantity": 1 } )
   db.inventory.find( { "stock.size": "M" } ).sort( { "stock.quantity": 1 } )

For more information on behavior of compound indexes and sort
operations, see :doc:`/tutorial/sort-results-with-indexes`.

.. class:: hidden

   .. toctree::
   
      /tutorial/create-a-multikey-index
      /core/multikey-index-bounds
